\section{Marco teórico}
\subsection{Sistemas de Gestión de Horarios Académicos}
Imagina una herramienta clave en las instituciones educativas: un sistema de gestión de horarios académicos, creado para optimizar la asignación de recursos escasos como profesores, aulas y tiempos de clase. Estos sistemas unen datos diversos, desde la disponibilidad de docentes hasta restricciones curriculares, capacidades de salas y preferencias estudiantiles, usando algoritmos de optimización combinatoria para evitar conflictos y crear horarios funcionales.

En la literatura, destacan historias de éxito en universidades donde plataformas automatizadas han cortado drásticamente el tiempo de planificación manual, dejando a los administradores libres para centrarse en lo pedagógico \cite{desarrollo2025}. Por ejemplo, en campos logísticos parecidos, apps web y backend han mostrado su efectividad en optimizar recursos, adaptándose a imprevistos como cancelaciones o cambios de último minuto \cite{macias2021}.

La evolución de estos sistemas viene de la necesidad de lidiar con volúmenes de datos cada vez mayores y restricciones complejas. Investigaciones comparativas revelan que algoritmos heurísticos, como backtracking o programación lineal, son habituales para afrontar el problema de asignación de horarios, que es NP-completo en esencia \cite{torres2020}. Además, integrar datos en tiempo real, como actualizaciones de disponibilidad, demanda arquitecturas que manejen eventos asíncronos, impulsando el uso de patrones de mensajería y APIs eficaces.

\subsection{Arquitecturas de Software: Monolito vs Microservicios}
Cuando la escala de un sistema de gestión de horarios crece—ya sea por el número de usuarios, la complejidad de los datos o la frecuencia de actualizaciones—La arquitectura subyacente se vuelve crítica. Historicamente, muchos sistemas educativos comenzaron como monolitos, donde toda la lógica de aplicación reside en una sola unidad desplegable. Sin embargo, experiencias documentadas, como la migración de sistemas de transporte público a microservicios, demuestran que dividir la aplicación en servicios pequeños e independientes mejora la escalabilidad horizontal, reduce tiempos de respuesta y facilita el mantenimiento \cite{torres2020}. En un monolito, cambios en una parte del sistema pueden afectar al conjunto, mientras que en microservicios, cada servicio puede evolucionar de forma autónoma, permitiendo despliegues selectivos y recuperación de fallos granular.

En el contexto de SGH, se adopta un enfoque híbrido: un monolito modular en Spring Boot que simula microservicios lógicamente separados, permitiendo una futura transición sin refactorizaciones masivas. Esta decisión equilibra simplicidad en el desarrollo inicial con potencial de escalabilidad, alineándose con prácticas recomendadas para proyectos académicos de mediana escala \cite{torres2020}.

\subsection{Tecnologías Frontend: Next.js y Tailwind CSS}
El frontend web tiene un papel crucial en la usabilidad de sistemas como SGH, donde interfaces intuitivas son esenciales para administradores y profesores. Next.js, un framework basado en React, destaca por su capacidad de renderizado del lado del servidor (SSR) y generación de sitios estáticos (SSG), optimizando el rendimiento, mejorando el SEO y reduciendo tiempos de carga iniciales. Comparaciones entre frameworks JavaScript indican que Next.js ofrece una curva de aprendizaje amigable para equipos que conocen React, con una comunidad sólida que acelera el desarrollo \cite{lazuardy2022}. En proyectos parecidos, Next.js se ha usado para crear dashboards administrativos con navegación suave y componentes reutilizables, probando su idoneidad para apps de gestión educativa.

Complementando Next.js, Tailwind CSS proporciona un sistema de estilos utilitarios que permite diseños responsivos y modernos sin escribir CSS personalizado. Esta aproximación reduce el tiempo de desarrollo, mejora la consistencia visual y facilita la adaptación a dispositivos móviles. Experiencias en desarrollo web con Tailwind destacan su eficacia en la creación de interfaces limpias y accesibles, con soporte para temas oscuros y animaciones sutiles \cite{somi2021}. En el caso de SGH, la combinación de Next.js y Tailwind permite una interfaz web que responde rápidamente a interacciones del usuario, visualizando horarios en formatos como calendarios y tablas dinámicas.

\begin{figure}[h]
\centering
\includegraphics[width=0.8\columnwidth]{graphics/uno.png}
\caption{Modern Front End Web Architectures with React.Js and Next.Js.}
\label{fig:lazuardy}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[width=0.8\columnwidth]{graphics/dos.png}
\caption{User Interface Development of a Modern Web Application.}
\label{fig:somi}
\end{figure}

\subsection{Tecnologías Backend y Comunicación: Spring Boot y APIs REST}
En el backend, Spring Boot emerge como una opción madura para desarrollar servicios robustos y escalables. Su integración con JPA para persistencia de datos, Spring Security para autenticación, y soporte nativo para APIs REST lo hace ideal para sistemas como SGH, donde la lógica de negocio incluye algoritmos de optimización y manejo de entidades complejas. Spring Boot facilita la configuración de microservicios modulares, con controladores para endpoints REST, servicios para lógica de negocio y repositorios para acceso a datos, promoviendo una arquitectura limpia y mantenible.

La comunicación entre frontend y backend se basa en APIs REST, un protocolo estandarizado sobre HTTP que permite operaciones CRUD sobre recursos. Este enfoque desacopla clientes y servidores, facilitando evoluciones independientes y escalabilidad. En proyectos con React Native y Next.js, las APIs REST han probado su viabilidad para aplicaciones móviles y web, con baja sobrecarga y soporte para autenticación JWT y cifrado \cite{amodeo2013, macias2021}. En SGH, las APIs REST manejan solicitudes de creación, lectura, actualización y eliminación de cursos, profesores y horarios, asegurando interoperabilidad y facilidad de integración con futuros módulos.

\begin{figure}[h]
\centering
\includegraphics[width=0.8\columnwidth]{graphics/tres.png}
\caption{Principios de diseño de APIs REST.}
\label{fig:amodeo}
\end{figure}

\subsection{Tecnologías Móviles: React Native}
Para acceso multiplataforma, React Native permite desarrollar aplicaciones móviles nativas usando JavaScript, compartiendo lógica con el frontend web. Estudios comparativos entre frameworks móviles, como Flutter y React Native, destacan la superioridad de este último en términos de comunidad y facilidad de integración con ecosistemas React \cite{macias2021}. En SGH, React Native se utiliza para una app móvil que consume las mismas APIs REST, ofreciendo funcionalidades como visualización de horarios y notificaciones, optimizada inicialmente para Android con potencial de extensión a iOS.

\begin{figure}[h]
\centering
\includegraphics[width=0.8\columnwidth]{graphics/cuatro.png}
\caption{Estudio comparativo de los frameworks del desarrollo móvil.}
\label{fig:macias}
\end{figure}

\subsection{Seguridad y Privacidad en Sistemas Educativos}
La seguridad es un pilar fundamental en sistemas que manejan datos sensibles como información personal de estudiantes y profesores. Una autenticación coherente entre plataformas web y móvil, utilizando JWT para tokens seguros, es esencial; diseños unificados para React y React Native incluyen registro, login, recuperación de credenciales y manejo de tokens JWT \cite{ye2022}. Además, se recomienda control de acceso basado en roles, cifrado de comunicaciones vía HTTPS y cumplimiento de regulaciones como GDPR o leyes locales de protección de datos.

Más allá de lo técnico, principios de privacidad por diseño son cruciales en entornos educativos, donde el manejo ético de datos previene abusos. Aprendiendo de aplicaciones de rastreo de contactos, que incorporan enfoques de privacidad reforzada con consentimiento explícito y minimización de datos \cite{react2021}, SGH implementa medidas para asegurar que la gestión de horarios no comprometa la privacidad, como encriptación de datos en reposo y auditorías regulares.